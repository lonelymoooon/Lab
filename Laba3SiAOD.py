# 1.Напишите функцию, которая транспонирует двумерный массив.
# import numpy as np  # библиотека, которая добавляет поддержку больших
# многомерных массивов и мачриц вместе с библиотекой мат функций для операций с ними

a = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]


def trahsposed(x):
    matrix = np.transpose(x)  # собственно функция этой библиотеки для транспонирования
    return matrix


print(trahsposed(a))  # можно решить через zip, но хотелось побаловаться

# 2.Написать функцию, которая в качестве параметра принимает список кортежей
# (кортежи содержат следующую информацию - Кличка животного, Возраст животного,
# Имя владельца, Фамилия владельца) и оптимизирует хранение данных таким образом, чтобы для
# каждому владельцу соответствовали все его животные.

Пример входных данных: [('Муся', 7, 'Игорь', 'Бероев'), ('Изольда', 2, 'Игорь', 'Бероев')].
a = [('Барсик', 5, 'Иван', 'Иванов'), ('Мурка', 4, 'Иван', 'Иванов'),
     ('Рыжик', 2, 'Петр', 'Петров'), ('Том', 1, 'Михаил', 'Сидоров')]


def optimize(pets): # принимаем список кортежей

    owners = {}  # словарь, который будет хранить инфу (имя животного, возраст, ФИ владельца)

    for pet in pets: # пробегаемся
        name, age, owner_name, owner_surname = pet  # разбираем кортеж pet на отдельные значения
        owner = (owner_name, owner_surname)  # объединяем имя и фамилию владельца в кортеж
        if owner not in owners:  #  если кортеж отсутствует в словаре, мы добавляем в него запись с ключом owner и
            # со значением пустого списка.
            # это значит, что данного владельца еще не было в словаре
            owners[owner] = []
        owners[owner].append((name, age))  # добавляем текущее животное (кличка и возраст) в список значений словаря

    return owners

print(optimize(a))

# 3.Напишите функцию, которая принимает на вход строку, и выводит слово, которое встречается во фразе реже всего.
# Если редких слов несколько, нужно вывести то, которое меньше в лексикографическом порядке. Регистр слов не
# учитывается, знаки препинания в предложениях игнорируются.
a = 'вышла вышла курица на улицу снесла курица яйцо'


def keke(string):
    if not string or string.isdigit():
        return 'чо'

    string = ''.join(s.lower() for s in string if s.isalpha() or s.isspace()) # удаляем все символы пунктуации,
    приводим к нижнему регистру и удаляем пробелы

    words = string.split() # разбиваем строку на слова

    count = {}  # словарь для хранения количества появлений каждого слова

    # проходим по каждому слову в списке
    for word in words:
        if word in count:  # если слово уже есть в словаре, то увеличиваем частоту его встречаемости
            count[word] += 1
        else:
            count[word] = 1

    # находим самое редко встречающееся слово
    min_count = float("inf")
    # inf (infinity - бесконечность) специальный тип данных, который представляет положительную бесконечность
    # в начале работы мы не знаем, какая будет минимальная частота встречаемости элементов в списке.
    # благодаря этой записи, мы создаем условие, при которой 1ый элемент в списке всегда будет с наименьшей частотой
    min_word = ''

    for word in count:
        if count[word] < min_count:  # если текущая частота меньше минимального
            min_count = count[word]  # обновляем значение
            min_word = word
        elif count[word] == min_count:  # иначе если текущее равно минимальной
            if word < min_word:
                min_word = word

    return min_word

print(keke(a))

# 4.Напишите функцию, которая принимает на вход строку, содержащую разные буквы латинского алфавита и символы пунктуации
# и возвращает букву, которая встречается чаще всего. Если таких букв больше одной, то нужно вернуть ту, что стоит выше
# в алфавите. Регистр букв не учитывается, то есть «А» == «а».

a = 'я котик ты котик'
def pepe(string):
    if not string or string.isdigit():
        return 'чо'

    string = ''.join(s.lower() for s in string if s.isalpha())  # удаляем все символы пунктуации и приводим буквы
    # к нижнему регистру

    count = {}  # словарь для хранения количества появлений каждой буквы

    # проходим по каждому символу в строке
    for s in string:
        if s in count:  # если символ уже есть в словаре, то увеличиваем частоту его встречаемости на 1
            count[s] += 1
        else:
            count[s] = 1  # иначе добавляем его в словарь

    # находим самую часто встречающуюся букву
    max_count = 0  # максимальная частота
    max_letter = ''  # буква котора чаще всего встречалась

    for s in count:
        if count[s] > max_count:  # если текущая частота больше максимальной
            max_count = count[s]  # обновляем значение
            max_letter = s
            # для того, чтобы вывести ту букву, что выше в алфавите
        elif count[s] == max_count:  # иначе если текущая равна максимальной
            if ord(s) < ord(max_letter):  # сравниваем код символа s с кодом символа, который мы выбрали как наиболее
                # часто встречающийся. (чем дальше символ в алфавите, тем больше его код)
                max_letter = s

    return max_letter  # возвращаем букву, которая встречалась чаще всего


print (pepe(a))

# 5.Напишите функцию, которая принимает на вход строку и определяет, является ли она палиндромом. Использовать рекурсию.

a = 'аргентина манит негра'

def palindrome(string):
    задача с подвохом, которую мы решали с сашенькой
    string = string.replace(' ', '') # убрали пробелы
    
    result = True
    if len(string) > 1:
        if string[0].lower() == string[-1].lower(): # не учитываем регистр, сравниваем первый и последний элементы
            result = palindrome(string[1:-1]) # рекурсивно вызываем функцию без первого и последнего символа
        else:
            result = False
    return result

print(palindrome(a))

# 6.Напишите функцию, которая принимает на вход массив чисел и сортирует его по частоте элементов. Если два элемента
# имеют одинаковую частоту, то нужно отсортировать по порядку появления в массиве.
a = [1, 9, 0, 9, 0, 1]


def sort(x):

    count = {} # словарь для хранения частоты каждого элемента

    for elem in x: # проходим по каждому элементу массива
        if elem in count:  # если элемент уже есть в словаре, то увеличиваем частоту
            count[elem] += 1
        else:
            count[elem] = 1 # если еще нет, то добавляем в словарь

    # сортируем массив по частоте элементов
    res = sorted(x, key=lambda y: (-count[y], x.index(y)))  # функция возвращает кортеж из двух значений (отрицательное
    # значение частоты элемента (чтобы элементы с более высокой частотой оказывались первыми в отсортированном массиве)
    # и индекс элемента), если два элемента имеют одинаковую частоту, то они будут отсортированы
    # в порядке их появления

    return res


print (sort(a))

# 7.Напишите функцию, которая принимает на вход строку, состоящую из слов и чисел, разделенных одним пробелом. Слова
# состоят только из букв. Определить, имеется ли в передаваемой строке непрерывная последовательность из трех слов.
a = 'вышел зайчик на 123 крыльцо почесать 22 свое что ?'


def three_words(x):
    words = x.split() # разделяем строку
    for i in range(2, len(words)): # начинаем с 3 элемента
        if all(word.isalpha() for word in words[i-2:i+1]): # являются ли предыдущие три элемента словами
            return True # если да, то суппер, возвращаем true
    return False


print(three_words(a))

# 8.Напишите функцию, которая принимает на вход строку и возвращает максимальную длину непрерывной
# последовательности одинаковых букв.

def max_length(x):
    x = x.lower()  # не учитываем регистр
    maximum = 0  # максимальная длина
    current = 1  # текущая длина

    for i in range(1, len(x)):  # проходимся по символам в строке, начиная со второго символа
#         если текущий символ равен предыдущему, увеличиваем текущую длину последовательности на 1
        if x[i] == x[i - 1] and x.isalpha(): # и х буковка
            current += 1
        else:
#             если текущая длина последовательности больше максимальной, обновляем
            if current > maximum:
                maximum = current
            обнуляем
            current = 1

#     является ли текущая длина последовательности больше максимальной
    if current > maximum:
        maximum = current
    
    return maximum


string = 'aaaaaaabbcfffffffffffffff'
print(max_length(string))


# 9.Напишите функцию, которая в качестве параметра принимает строку и вычисляет введенное там арифметическое выражение.
# Пример входных данных: “2+2*2”, результат выполнения: 6

a = '256*8'
def me (x):
    chars = '0123456789.+-*/()'  # допустимые символы
    if not all (i in chars for i in x):  # содержит ли строка только допустимые символы
        raise ValueError('Недопустимый символ')  # если нет, то выдаем ошибку

    result = eval(x)  # эта функция анализирует аргумент, оценивает его как выражение и запускает код

    return result

print(me(a))

# 10.Напишите функцию, которая в качестве параметра принимает список словарей (в качестве ключей – строки, в качестве
# значений – числа) и выполняет следующую процедуру:
# Если ключ есть в нескольких словарях, то в новый словарь добавить этот ключ, а в качестве значения использовать сумму
# всех значений.
# Если ключ есть только в одном из словарей, то просто добавить его в новый словарь. Вернуть новый словарь

dict_list = [{'a': 1, 'b': 2, 'c': 3},
             {'a': 4, 'b': 5, 'd': 6},
             {'b': 7, 'd': 8, 'e': 9}]  # наш список из трех словарей


def sum_dicts(x):
    result = {} # новый словарь

    for dictе in x:
        for key, value in dictе.items():  # перебирает все пары ключ-значения из словарей
            if key not in result:  # если ключ нет в словаре,  то он добавляется в него
                result[key] = value  # в качестве значения устанавливается соответствующее значение из текущей пары
            else:
                result[key] += value # иначе увеличиваем на соответсвующее значение

    return result

print(sum_dicts(dict_list))
