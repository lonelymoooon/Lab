1.Написать функцию для вычисления n-ого элемента последовательности Фибоначчи (используя рекурсию).
Пример: 6 -> 8
def fibo(n):
    if n == 1 or n == 2:
        return 1 #первый и второй элементы ряда Фибоначчи равны единице
    return fibo(n - 1) + fibo(n - 2) #вызываем ту же функцию с аргументами n-1 и n-2

print(fibo(10))

2. Из двух списков удалить все элементы, которые есть в обоих списках.
Пример: [1,2,3,4,5,6], [4,5,6,7,8,9] -> [1,2,3], [7,8,9]

a = [1, 2, 3, 4, 5, 6]
b = [4, 2, 5, 6, 7, 8, 9]

def remov(k, m):
    for i in range (len(k)+1): # к длине списка прибавляем единичку,
        # чтобы учитывался последний элемент
        if i in m:
            k.remove(i) # если i находится в k и далее находится в m,
            # то и там, и там оно удаляется при помощи remove
            m.remove(i)
    return k, m

print(remov(a, b))


3.Извлечь из списка все элементы, которые встречаются не реже заданного числа раз.
Пример: [1,2,3,3,3,3,3], 4 -> 3

a = [1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8]
k = 2  # столько раз должны встречаться элементы
res = []  # список, в который будут записываться элементы (>=2)

for i in set(a):  # set удаляет все дубликаты в списке
    if a.count(i) >= k: # количество раз, когда элемент встречается в списке
        res.append(i)

print('Эти элементы встречаются минимум 2 раза:')
print(*res, sep=', ') # это шобы оно выводилось без квадратных скобок, спасибо интернеты


4.Заменить в списке все вложенные списки суммой их элементов
Пример: [1, [2, [3,4]] -> [1, [2, 7]] -> [1, 9]
l = [1, [2, [3, 4]]]


def summa(x): # буду честна, с этим моментом мне помогла Саша Степанова, просто мой спаситель
    a = []
    for i in x:
        if isinstance(i, list):
            try: # про try-except я знаю, но я им нечасто пользовалась и не знаю, как сделать так, чтобы код работал
                #  без него, ибо оно ругается на не список. конструкция try-except как раз-таки спасает от этого
                b = sum(i)
                a.append(b)
            except TypeError:
                listik = [flatten(i)] # делаем один подсписок, чтобы не ругалось
                a.extend(summa(listik)) # он отправляется на повторное суммирование
        else:
            a.append(i)
    return a


def flatten(x): # код взятый из прошлой лабы
    a = []
    for i in x:
        if isinstance(i, list):
            a.extend(flatten(i))
        else:
            a.append(i)
    return a

print (flatten(l))



print(summa(l))

5.Найти наибольшую возрастающую подпоследовательность в списке.
Пример: [1,2,3,2,4,5,6,7] -> [4,5,6,7]

l = [1, 2, 3, 6, 8, 9, 2, 1, 2, 4, 5, 6, 7]


def posl(x):
    current = [] # сюда будет записываться текущая последовательность
    maximum = [] # сюда будет записываться максимальная последовательность
    for i in range(len(x)):
        if i == 0 or x[i] <= x[i - 1]: # если текущий элемент меньше или равен предыдущему
            current = [x[i]] # начинается новая текущая последовательность
        else:
            current.append(x[i]) # иначе добавляем текущий элемент к существующей последовательности
        if len(current) > len(maximum): # если текущая длиннее наибольшей, то как бы да, сохраняем ее в наибольшую
            maximum = current
    return maximum

print(posl(l))


6.Привести заданную строку к стилю “заборчиком”.
Пример: “чмаф всех в чатике” -> “ЧмАф ВсЕх В чАтИке”

def zabor(x):
    x = '' #сюда будет записываться результат
    for i in range (len(s)):
        if i % 2 == 0: #благодаря этому условию чередуем буквы, создавая ЗаБоРчИк
            x += s[i].upper() #делает большую букву
        else:
            x += s[i].lower() #делает маленькую букву
    return x


s = 'я умер в 16 лет и теперь я всегда выгляжу как в 16 лет'
print(zabor(s))



7.На вход подается ширина и высота. По этим параметрам нарисовать ромб, используя на выбор один из символов: #, *, +
Пример:
   #
 #  #
#    #
 #  #
   #

width = 13
height = 7
symbol = '*'

def diamond(width, height, symbol):
    if height % 2 == 0:
        height -= 1  # уменьшаем высоту, если она четная для симметричности
    mid = height // 2 + 1  # находим середину ромба
    for i in range(1, height + 1):
        row = ''
        if i <= mid:  # отрисовка верхней половины ромба
            spaces = mid - i
            diamonds = i * 2 - 1
            row += ' ' * spaces + symbol * diamonds + ' ' * spaces
        else:  # отрисовка нижней половины ромба
            spaces = i - mid
            diamonds = (height - i + 1) * 2 - 1
            row += ' ' * spaces + symbol * diamonds + ' ' * spaces
        print(row.center(width, ' '))  # центрируем текущую строку в зависимости от заданной ширины

diamond(width, height, symbol)


8.Заполнить квадратную матрицу так, чтобы все числа первого столбца и первой строки были равны 1,
а каждое из оставшихся чисел равно сумме верхнего и левого соседей. Вывести на экран матрицу данного размера.
Пример:
1   1   1   1
1   2   3   4
1   3   6   10
1   4   10 20

def create_mat(n):
    matrix = [[0] * n for i in range(n)] # создаем маЧрицу n x n с нулями
    for i in range(n):  # заполняем первую строку и первый столбец нашей маЧрицы единицами
        matrix[0][i] = 1 # элемент матрицы и его индекс
        matrix[i][0] = 1
    for i in range(1, n):  # заполняем оставшуюся часть нашей маЧрицы
        for j in range(1, n):
            matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]  # Значение текущей ячейки равно
            # сумме верхней и левой ячеек
    return matrix


def pechat_mat(n):
    matrix = create_mat(n)
    for i in range(n):  # выводим нашу маЧрицу на экран
        for j in range(n):
            print(matrix[i][j], end=' ')  # запись в конце нужна шобы норм выводилось
        print()  # перенос строки


pechat_mat(4)

9.Найти сумму всех чисел в строке.
Пример: “В этой 1 строке 4 всего 5 четыре числа 9” -> 19


def sum_of_numbers(x):

    result = '' # переменная для хранения чисел и пробелов
    for i in x:
        if i.isdigit() or i.isspace(): # если наш символ цифра или пробел, то добавляем
            result += i
        else:
            continue

    result = result.strip() # очищаем полученную строку от пробелов
    numbers_list = [int(num) for num in result.split() if num.isdigit()] # преобразуем строку чисел в список чисел
    numbers_sum = sum(numbers_list)

    return numbers_sum


x = "19коров и кита3 выш33ло в поле 1"
result = sum_of_numbers(x)
print(result)


10.То же самое, но без явной конвертации (не используя int())

def sum_of_numbers(x):  # умереть не встать, зачем нужна неявная конвертация
    words = x.split()
    res = 0
    for word in words:  # до этого момента все как и в прошлом коде
        if all(c.isdigit() for c in word):  # проверка, состоит ли текущий элемент только из чисел
            # если да, то переводим его в числовое значение и добавляем к общей сумме
            num = 0
            for c in word:
                num = num * 10 + ord(c) - ord('0')  # ord вернет для символа число из таблицы символов Unicode
                # метод позиционной записи чисел. символ '0' (его код ASCII равен 48) вычитается из числового
                # значения символа, чтобы получить числовое значение цифры
                res += num
    return res


sentence = "434 В этой 12 строке 45 всего 52 четыре 1 числа 93"
print(sum_of_numbers(sentence))

